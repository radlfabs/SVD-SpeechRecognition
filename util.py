# -*- coding: utf-8 -*-
"""
@author: F.Rosenthal, P.Schwarz
"""

import os
import matplotlib as mpl
import matplotlib.pyplot as plt
import tracemalloc
import numpy as np
import json
import pandas as pd
from itertools import product
from sklearn.metrics import ConfusionMatrixDisplay
from matplotlib.backends.backend_pdf import PdfPages


mpl.rcParams['mathtext.fontset'] = 'stix'
mpl.rcParams['font.family'] = 'STIXGeneral'


def tracking_start():
    tracemalloc.stop()
    # print("Tracing status: ", tracemalloc.is_tracing())
    tracemalloc.start()
    # print("Tracing status: ", tracemalloc.is_tracing())


def tracing_mem():
    first_size, first_peak = tracemalloc.get_traced_memory()
    peak = first_peak / (1024 * 1024)
    print(f"Peak Size: {peak} MB")


def format_time(seconds):
    minutes = seconds // 60
    hours = int(minutes // 60)
    seconds = int(seconds % 60)
    minutes = int(minutes % 60)
    return "{:02d}:{:02d}:{:02d}".format(hours, minutes, seconds)


def plot_spectrogram(t, f, Sxx):
    """
    Plots spectrograms as output by scipy.
    txf should be the dimensions of Sxx.

    Parameters
    ----------
    t : Time vector.
    f : Frequency vector.
    Sxx : Array containing the spectrogram levels.

    Returns
    -------
    None.

    """
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    fig = plt.figure()
    plt.pcolormesh(t, f, Sxx, shading='gouraud')
    plt.ylabel('Frequency [Hz]')
    plt.xlabel('Time [sec]')
    plt.show()
    plt.close(fig)


def plot_graph(data, title, xlabel='Test Samples', ylabel='Error Rate', ylim=None, ground=False):
    """
    Plots given data as line plot.

    :param data: Array containing data points for plotting
    :param title: Title of the plot
    :param xlabel: Name of horiziontal axis
    :param ylabel: Name of the vertical axis
    :param ylim: Value bounds for displaying values
    :param ground: If true, vertical axis will start at zero
    """
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    n = np.arange(0, np.size(data))
    fig = plt.figure(dpi=300)
    plt.plot(n, data)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if ground:
        plt.ylim(bottom=0)
    if ylim is not None:
        plt.ylim(ylim)
    plt.title(title)
    plt.savefig(f"plots/{title}.png")
    plt.close(fig)


def plot_multiline_graph(data, title):
    """
    Plots given data as multiple line diagrams.

    :param data: 2D-Array containg the data to plot
    :param title: Title of the diagram
    """
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    keys = list(data.keys())
    n = np.arange(0, np.size(data[keys[0]]))
    fig = plt.figure(dpi=300)
    for k in data.keys():
        plt.plot(n, data[k], label=f"k={k} er={data[k][-1]}")  # FR: got KeyError from data[k][-1]
    plt.legend()
    plt.xlabel("Test samples")
    plt.ylabel("Error Rate")
    plt.ylim([0, 1])
    plt.title(title)
    plt.savefig(f"plots/error_rates_{title}.png")
    plt.close(fig)


def generate_random_plot_data(data):
    """
    Generates random data points and fills the residual fields in the report data
    :param data: report data
    :return: data report, filled with random residual values
    """
    import random
    for id in data['results'].keys():
        data['results'][id]['residuals'] = []
        for i in range(10):
            data['results'][id]['residuals'].append(random.randint(1, 100))
    return data


def plot_confusion_matrix(data, savestring=""):
    """Wrapper function for sklearn's ConfusionMatrixDisplay.
    The input dictionary will be used to plot a row-normalized confusion Matrix.
    It will help exploring errors over classes. The matrix is saved as a pdf files.

    Args:
        data (dict): Results dictionary as generated by digit_classifer().
        savestring (str, optional): Additional info to pass to the diagrams filename. Defaults to "".
    """

    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    y_true = []
    y_pred = []
    for k in data['results'].keys():
        y_true.append(data['results'][k]['actual'])
        y_pred.append(data['results'][k]['estimated'])
    cm = ConfusionMatrixDisplay.from_predictions(y_true=y_true, y_pred=y_pred,
                                                 labels=list(range(10)),
                                                 normalize='true')
    fig, ax = plt.subplots(dpi=300)
    cm.plot(ax=ax, values_format='.2f')
    ax.set_ylabel("Actual Digit")
    ax.set_xlabel("Predicted Digit")
    plt.savefig(f"plots/confusionmatrix_{savestring}.pdf", format="pdf", bbox_inches="tight")
    plt.close(fig)
    del ax


def plot_residuals(data, savestring=""):
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    """A function to make subplots of residuals over base digits for every actual digit class.
    Plot inspired by Elden.
    Resulting plot will be saved as a PNG-file.
    Take this module's boxplot_residuals() to get statistically more useful plots.

    Args:
        data (dict): A dict where the classification results are stored.
        savestring (str, optional): Additional string with metadata to pass to save-filename. Defaults to "".
    """
    residuals_per_digit = {}
    for i in range(10):
        residuals_per_digit[str(i)] = []
    for id in data['results'].keys():
        k = str(data['results'][id]['actual'])
        residuals_per_digit[k].append(list(data['results'][id]['residuals']))

    fig, axs = plt.subplots(2, 5, figsize=(10, 5), dpi=300, sharey=True)
    # plt.suptitle("Residuals vs. tested basis for every actual Digit.", fontsize=18, y=0.95)
    for i, ax in enumerate(axs.flat):
        for residual_list in residuals_per_digit[str(i)]:
            ax.semilogy(list(range(10)), residual_list, 'k', alpha=0.04)
        ax.set(xlabel='Tested Basis', ylabel='$\log_{2}(Residual)$')
        ax.set_title(f"Digit Class {str(i)}")
        ax.label_outer()
    plt.setp(axs, xticks=list(range(10)), xticklabels=list(range(10)))
    plt.tight_layout(rect=[0, 0.03, 0.9, 0.9])
    plt.savefig(f"plots/residualplot_{savestring}.pdf", format="pdf", bbox_inches="tight")
    plt.close(fig)


def boxplot_residuals(data, savestring=""):
    """A function to make subplots of residuals over base digits for every actual digit class.
    Resulting plot will be saved as a PNG-file.

    Args:
        data (dict): A dict where the classification results are stored.
        savestring (str, optional): Additional string with metadata to pass to save-filename. Defaults to "".

    The first few lines are needed to transfor data from corresponding to the test sample
    to corresponding to a hierarchy of actual digit classes instead.
    This is what we are actually interested in here since we want to plot statistical information for every digit class.
    The dict from json data is converted to a pandas DataFrame oriented with test samples as rows.
    The dataframe has collected residuals per test as a list in every field of column 'residuals'. This has to be split.
    We split the lists of residuals to new columns such that one column corresponds to a tested base.
    df[list(range(10))] just creates 10 columns with digits as names.
    We furthermore just index the dataframe efficiently such that we get columns as pandas series and can convert them to lists.
    We want to plot the boxplots by iterating through a dict. Lets call it box_dict.
    It's keys (digit_class) refer to the actual digit classes. Each value is a list of 10 arrays,
    each array consisting of all residuals for one combination of digit class and tested base
    We apply log2() on the array values to handle outliers.
    The x-labels have to be constructed with
        [""] + [str(i) for i in range(10)] + [""]
    because the boxplots need the positions 0 and 11 as xticks.
    """
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    df = pd.DataFrame.from_dict(data['results'], orient='index')
    df[list(range(10))] = pd.DataFrame(df.residuals.tolist(), index=df.index)
    box_dict = {digit_class: [] for digit_class in range(10)}
    for (digit_class, test_base) in product(range(10), range(10)):
        box_dict[digit_class].append(np.log2(df[test_base].loc[df['actual'] == digit_class].to_list()))

    x_labels = [""] + [str(i) for i in range(10)] + [""]
    fig, axs = plt.subplots(2, 5, figsize=(10, 5), dpi=300, sharey=True)
    # plt.suptitle("Boxplot of residuals vs. tested basis for every actual digit.", fontsize=18, y=0.95)
    for i, ax in enumerate(axs.flat):
        ax.boxplot(box_dict[i], showfliers=False)
        ax.set(xlabel='Tested Basis', ylabel='$\log_{2}(Residual)$')
        ax.set_title(f"Digit Class {str(i)}")
        ax.label_outer()
    plt.setp(axs, xticks=list(range(12)), xticklabels=x_labels)
    plt.tight_layout(rect=[0, 0.03, 0.9, 0.9])
    # plt.grid(True)
    plt.savefig(f"plots/residual_boxplots_{savestring}.pdf", format="pdf", bbox_inches="tight")
    plt.close(fig)
    del axs


def boxplot_residuals_multipage(data, savestring=""):
    """A function to make subplots of residuals over base digits for every actual digit class.
    Resulting plot will be saved as a PNG-file.

    Args:
        data (dict): A dict where the classification results are stored.
        savestring (str, optional): Additional string with metadata to pass to save-filename. Defaults to "".

    The first few lines are needed to transfor data from corresponding to the test sample
    to corresponding to a hierarchy of actual digit classes instead.
    This is what we are actually interested in here since we want to plot statistical information for every digit class.
    The dict from json data is converted to a pandas DataFrame oriented with test samples as rows.
    The dataframe has collected residuals per test as a list in every field of column 'residuals'. This has to be split.
    We split the lists of residuals to new columns such that one column corresponds to a tested base.
    df[list(range(10))] just creates 10 columns with digits as names.
    We furthermore just index the dataframe efficiently such that we get columns as pandas series and can convert them to lists.
    We want to plot the boxplots by iterating through a dict. Lets call it box_dict.
    It's keys (digit_class) refer to the actual digit classes. Each value is a list of 10 arrays,
    each array consisting of all residuals for one combination of digit class and tested base
    We apply log2() on the array values to handle outliers.
    The x-labels have to be constructed with
        [""] + [str(i) for i in range(10)] + [""]
    because the boxplots need the positions 0 and 11 as xticks.
    """
    os.makedirs(os.path.join(os.getcwd(), "plots"), exist_ok=True)
    df = pd.DataFrame.from_dict(data['results'], orient='index')
    df[list(range(10))] = pd.DataFrame(df.residuals.tolist(), index=df.index)
    box_dict = {digit_class: [] for digit_class in range(10)}
    for (digit_class, test_base) in product(range(10), range(10)):
        box_dict[digit_class].append(np.log2(df[test_base].loc[df['actual'] == digit_class].to_list()))

    x_labels = [""] + [str(i) for i in range(10)] + [""]

    with PdfPages('multipage_pdf.pdf') as pdf:
        fig, axs = plt.subplots(3, 1, figsize=(4.7, 7.5), dpi=300, sharey=True)
        # plt.suptitle("Boxplot of residuals vs. tested basis for every actual digit.", fontsize=18, y=0.95)
        for i, ax in zip(range(0, 3), axs.flat):
            ax.boxplot(box_dict[i])
            ax.set(xlabel='Tested Basis', ylabel='$\log_{10}(Residual)$')
            ax.set_title(f"Actual Digit {str(i)}")
        plt.setp(axs, xticks=list(range(12)), xticklabels=x_labels)
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        pdf.savefig(fig)  # f"plots/residual_boxplots_{savestring}.pdf", format="pdf", bbox_inches="tight")
        plt.close(fig)

        fig, axs = plt.subplots(3, 1, figsize=(4.7, 7.5), dpi=300, sharey=True)
        # plt.suptitle("Boxplot of residuals vs. tested basis for every actual digit.", fontsize=18, y=0.95)
        for i, ax in zip(range(3, 6), axs.flat):
            ax.boxplot(box_dict[i])
            ax.set(xlabel='Tested Basis', ylabel='$\log_{10}(Residual)$')
            ax.set_title(f"Actual Digit {str(i)}")
        plt.setp(axs, xticks=list(range(12)), xticklabels=x_labels)
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        pdf.savefig(fig)  # f"plots/residual_boxplots_{savestring}.pdf", format="pdf", bbox_inches="tight")
        plt.close(fig)

        fig, axs = plt.subplots(3, 1, figsize=(4.7, 7.5), dpi=300, sharey=True)
        # plt.suptitle("Boxplot of residuals vs. tested basis for every actual digit.", fontsize=18, y=0.95)
        for i, ax in zip(range(6, 9), axs.flat):
            ax.boxplot(box_dict[i])
            ax.set(xlabel='Tested Basis', ylabel='$\log_{10}(Residual)$')
            ax.set_title(f"Actual Digit {str(i)}")
        plt.setp(axs, xticks=list(range(12)), xticklabels=x_labels)
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        pdf.savefig(fig)  # f"plots/residual_boxplots_{savestring}.pdf", format="pdf", bbox_inches="tight")
        plt.close(fig)

        fig, ax = plt.subplots(1, 1, figsize=(4.7, 2.5), dpi=300, sharey=True)
        # plt.suptitle("Boxplot of residuals vs. tested basis for every actual digit.", fontsize=18, y=0.95)
        i = 9
        ax.boxplot(box_dict[i])
        ax.set(xlabel='Tested Basis', ylabel='$\log_{10}(Residual)$')
        ax.set_title(f"Actual Digit {str(i)}")
        plt.setp(axs, xticks=list(range(12)), xticklabels=x_labels)
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        pdf.savefig(fig)  # f"plots/residual_boxplots_{savestring}.pdf", format="pdf", bbox_inches="tight")
        plt.close(fig)


if __name__ == '__main__':
    path = "number_metrics_7500_1500.json"
    with open(path) as json_file:
        data = json.load(json_file)
    plot_confusion_matrix(data)
    plot_residuals(data)
    boxplot_residuals(data)
    print("Plots have been saved to 'plots/'.")
